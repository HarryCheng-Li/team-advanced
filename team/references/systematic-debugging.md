# Systematic Debugging - 系统化调试

> 版本: 1.0.0 | 更新时间: 2026-02-20
> 来源: Superpowers

---

## 概述

系统化调试是一种结构化的问题解决方法，强调理解根因而非随机尝试。

```
┌─────────────────────────────────────────────────────┐
│           系统化调试核心理念                         │
├─────────────────────────────────────────────────────┤
│  传统方法: 报错 → 改代码 → 试一下 → 重复           │
│                                                     │
│  系统化方法: 根因调查 → 模式分析 → 假设测试 → 实现  │
│                                                     │
│  核心原则: 无根因不修复 (IL-002)                    │
└─────────────────────────────────────────────────────┘
```

---

## 四阶段流程

```
┌─────────────────────────────────────────────────────┐
│          Phase 1: 根因调查                          │
├─────────────────────────────────────────────────────┤
│  目标: 理解 WHAT 和 WHY                            │
│                                                     │
│  步骤:                                             │
│  1. 仔细阅读错误信息                               │
│  2. 复现问题                                       │
│  3. 检查最近的变更                                 │
│  4. 收集证据 (日志、堆栈、数据)                    │
│                                                     │
│  输出: 清晰的问题描述和初步原因假设                 │
└─────────────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────┐
│          Phase 2: 模式分析                          │
├─────────────────────────────────────────────────────┤
│  目标: 识别差异点                                   │
│                                                     │
│  步骤:                                             │
│  1. 找一个工作的示例                               │
│  2. 对比工作示例和失败案例                         │
│  3. 列出所有差异                                   │
│  4. 排除无关差异                                   │
│                                                     │
│  输出: 潜在问题点列表                               │
└─────────────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────┐
│          Phase 3: 假设测试                          │
├─────────────────────────────────────────────────────┤
│  目标: 确认或否定假设                               │
│                                                     │
│  步骤:                                             │
│  1. 形成明确假设: "问题可能是 X"                   │
│  2. 设计最小测试验证假设                           │
│  3. 执行测试                                       │
│  4. 分析结果                                       │
│     - 确认 → 进入 Phase 4                          │
│     - 否定 → 形成新假设，重复 Phase 3              │
│                                                     │
│  输出: 验证的根因                                   │
└─────────────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────┐
│          Phase 4: 实现                              │
├─────────────────────────────────────────────────────┤
│  目标: 修复问题并验证                               │
│                                                     │
│  步骤:                                             │
│  1. 先创建失败的测试 (RED)                         │
│  2. 实现修复                                       │
│  3. 确认测试通过 (GREEN)                           │
│  4. 回归测试 (确保没有引入新问题)                  │
│  5. 记录到 findings.md                             │
│                                                     │
│  输出: Bug 解决，测试通过，文档更新                 │
└─────────────────────────────────────────────────────┘
```

---

## 关键原则

### 1. 3 次修复失败后质疑架构

```yaml
规则:
  - 如果同一问题尝试 3 次修复都失败
  - 不要继续修补
  - 质疑架构设计
  - 考虑重新设计方案

示例:
  - 修复了 3 次，每次都引入新问题 → 架构可能有根本缺陷
  - 同样的错误反复出现 → 设计模式不合适
```

### 2. 多组件系统先添加诊断日志

```yaml
规则:
  - 在多组件系统中
  - 问题定位困难时
  - 先添加诊断日志
  - 确定故障发生在哪一层

示例:
  - 前端 → API → 数据库
  - 不知道哪里出错
  - 在每一层添加日志
  - 找到故障点
```

### 3. 永不重复相同的失败动作

```yaml
规则:
  - 同样的方法失败后
  - 必须尝试不同的方法
  - 不允许完全重复

示例:
  ❌ npm install 失败 → npm install → npm install
  ✅ npm install 失败 → 检查网络 → 使用 yarn → 检查 package.json
```

---

## 调试模板

### Phase 1 模板: 根因调查

```markdown
## 根因调查报告

### 错误信息
```
<粘贴完整错误信息>
```

### 复现步骤
1. <步骤1>
2. <步骤2>
3. <触发错误的操作>

### 最近的变更
- <变更1>
- <变更2>

### 收集的证据
- 日志: <关键日志片段>
- 堆栈: <关键堆栈信息>
- 数据: <相关数据状态>

### 初步假设
<描述可能的原因>
```

### Phase 3 模板: 假设测试

```markdown
## 假设测试记录

### 假设 #<n>
**内容**: <假设内容>
**置信度**: <低/中/高>

### 测试设计
**方法**: <如何验证>
**预期结果**: <如果假设正确，应该看到什么>

### 测试结果
**实际结果**: <观察到什么>
**结论**: <确认/否定假设>

### 下一步
- [ ] 如果确认 → 进入实现
- [ ] 如果否定 → 新假设: <新假设内容>
```

---

## 常见错误模式

### 模式 1: 跳过调查直接修复

```yaml
错误: 不理解问题就开始改代码
症状:
  - "试试这个改法"
  - "可能是这里的问题"
  - 随机注释代码

正确做法:
  - 先完成 Phase 1 调查
  - 理解问题后再动手
```

### 模式 2: 忽略错误信息

```yaml
错误: 不仔细阅读错误信息
症状:
  - 直接搜索错误类型
  - 跳过错误堆栈
  - 忽略错误上下文

正确做法:
  - 完整阅读错误信息
  - 理解每一行堆栈
  - 检查错误上下文
```

### 模式 3: 过度修复

```yaml
错误: 修复范围过大
症状:
  - 一次改动多个地方
  - 顺便重构代码
  - 添加"改进"

正确做法:
  - 只修复根因
  - 最小化改动范围
  - 修复后回归测试
```

---

## 与 Team Skill 集成

### bug-hunter 角色

```yaml
职责: 执行系统化调试 Phase 1-3
输出:
  - 根因调查报告
  - 假设测试记录
  - 验证的根因

交接给: fix-implementer
```

### fix-implementer 角色

```yaml
职责: 执行系统化调试 Phase 4
输入:
  - 验证的根因
  - 修复建议

输出:
  - 失败的测试
  - 修复代码
  - 测试通过证明
```

### 与 Iron Laws 关系

| Iron Law | 在调试中的应用 |
|----------|----------------|
| IL-002 无根因不修复 | 必须完成 Phase 1-3 才能修复 |
| IL-003 无证据不完成 | 修复后必须有测试通过证据 |
| IL-005 无记录不决策 | 调查过程记录到 findings.md |

---

## 检查清单

### Phase 1 检查清单
- [ ] 完整阅读错误信息
- [ ] 成功复现问题
- [ ] 检查最近的代码变更
- [ ] 收集相关日志和数据
- [ ] 形成初步假设

### Phase 2 检查清单
- [ ] 找到工作的对比示例
- [ ] 列出所有差异
- [ ] 排除无关差异
- [ ] 缩小问题范围

### Phase 3 检查清单
- [ ] 假设明确可测试
- [ ] 测试最小化
- [ ] 结果明确 (确认/否定)
- [ ] 记录测试过程

### Phase 4 检查清单
- [ ] 先写失败的测试
- [ ] 实现修复
- [ ] 测试通过
- [ ] 回归测试
- [ ] 记录到 findings.md

---

## 参考资源

- [Superpowers GitHub](https://github.com/obra/superpowers) - 原始 Systematic Debugging
- [references/iron-laws.md](iron-laws.md) - IL-002: 无根因不修复
- [references/anti-patterns.md](anti-patterns.md) - AP-004: 重复失败动作
- [references/findings-system.md](findings-system.md) - 记录调试发现
